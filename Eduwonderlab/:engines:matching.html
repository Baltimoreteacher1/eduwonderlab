<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Matching Engine</title>
<style>
  :root{
    --bg:#f7f9fc; --card:#fff; --text:#111827; --muted:#6b7280;
    --border:#d9dfe8; --accent:#2563eb; --accent2:#111827;
    --good:#065f46; --warn:#92400e; --bad:#b91c1c;
  }
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:var(--bg);color:var(--text);}
  header{padding:14px 18px;border-bottom:1px solid var(--border);background:#fff;position:sticky;top:0;z-index:5}
  header .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;justify-content:space-between}
  .title{font-weight:900;font-size:16px}
  .meta{font-size:12px;color:var(--muted)}
  .pill{display:inline-flex;align-items:center;gap:8px;padding:8px 10px;border-radius:999px;border:1px solid var(--border);background:#fff;font-size:12px;color:var(--muted)}
  .wrap{max-width:1200px;margin:0 auto;padding:16px 16px 28px}
  .grid{display:grid;grid-template-columns:1.05fr .95fr;gap:12px}
  @media (max-width: 980px){ .grid{grid-template-columns:1fr} }
  .card{background:var(--card);border:1px solid var(--border);border-radius:14px;padding:12px;box-shadow:0 1px 0 rgba(0,0,0,.02)}
  h2{margin:0 0 8px 0;font-size:14px}
  .small{font-size:12px;color:var(--muted)}
  .btnrow{display:flex;flex-wrap:wrap;gap:8px;margin:10px 0}
  button{
    cursor:pointer;border:none;border-radius:12px;padding:10px 12px;
    font-weight:900;background:var(--accent);color:#fff;font-size:14px;
  }
  button.secondary{background:var(--accent2)}
  button.ghost{background:#fff;color:#111827;border:1px solid var(--border)}
  button:disabled{opacity:.55;cursor:not-allowed}
  button:focus,.tile:focus,textarea:focus{outline:3px solid rgba(17,24,39,.18);outline-offset:2px}

  .msg{display:none;white-space:pre-wrap;border-radius:14px;padding:12px;margin-top:10px;font-size:13px}
  .msg.err{border:1px solid rgba(185,28,28,.35);background:rgba(185,28,28,.06);color:var(--bad)}
  .msg.warn{border:1px solid rgba(146,64,14,.35);background:rgba(146,64,14,.06);color:var(--warn)}
  .msg.ok{border:1px solid rgba(6,95,70,.35);background:rgba(6,95,70,.06);color:var(--good)}

  .boards{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  @media (max-width: 760px){ .boards{grid-template-columns:1fr} }

  .col{border:1px solid var(--border);border-radius:14px;padding:10px;background:#fff}
  .colHead{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
  .tiles{display:grid;grid-template-columns:repeat(2, minmax(0, 1fr));gap:8px}
  @media (max-width: 560px){ .tiles{grid-template-columns:1fr} }

  .tile{
    border:1px solid var(--border);border-radius:14px;background:#fff;padding:10px;
    font-weight:900;cursor:pointer;user-select:none;min-height:52px;display:flex;align-items:center;
  }
  .tile .sub{display:block;font-weight:700;color:var(--muted);font-size:12px;margin-top:4px}
  .tile.dragging{opacity:.55}
  .tile.selected{box-shadow:0 0 0 3px rgba(37,99,235,.25)}
  .tile.good{border-color:rgba(6,95,70,.35);background:rgba(6,95,70,.05)}
  .tile.bad{border-color:rgba(185,28,28,.35);background:rgba(185,28,28,.05)}
  .dropZone{
    border:2px dashed var(--border);border-radius:14px;padding:10px;min-height:52px;
    display:flex;align-items:center;justify-content:space-between;gap:10px;background:#fff;
  }
  .dropZone strong{font-weight:900}
  .dropZone .hint{font-size:12px;color:var(--muted)}
  .pairRow{display:grid;grid-template-columns:1fr;gap:8px}
  .pairRow .dropZone{margin-bottom:8px}

  textarea{width:100%;min-height:120px;resize:vertical;padding:10px 12px;border-radius:12px;border:1px solid var(--border);font-size:14px;font-family:inherit}
  .req{color:var(--bad);font-weight:900}
  .rubric{font-size:12px;color:var(--muted);line-height:1.4}
  .rubric strong{color:#111827}

  .kv{display:flex;flex-wrap:wrap;gap:8px;margin:6px 0}
  .kv .pill{padding:6px 10px}
</style>
</head>
<body>

<header>
  <div class="row">
    <div>
      <div class="title" id="uiTitle">Matching Engine</div>
      <div class="meta" id="uiMeta">Loading config…</div>
    </div>
    <div class="kv">
      <span class="pill"><span>Standard:</span> <strong id="uiStandard">—</strong></span>
      <span class="pill"><span>WIDA:</span> <strong id="uiWida">—</strong></span>
      <span class="pill"><span>Mode:</span> <strong id="uiMode">click+drag</strong></span>
    </div>
  </div>
</header>

<div class="wrap">
  <div class="grid">

    <!-- LEFT: GAME -->
    <section class="card" aria-label="Game">
      <h2 id="uiPrompt">Match items from Column A to Column B.</h2>
      <div class="small" id="uiDirections">Click one from A, then one from B to match. Or drag B onto its A target.</div>

      <div class="btnrow">
        <button class="ghost" id="btnReset" type="button">Reset</button>
        <button class="ghost" id="btnHint" type="button">Hint</button>
        <button class="secondary" id="btnCheck" type="button">Check</button>
      </div>

      <div class="boards">
        <!-- Column A: prompts (drop zones) -->
        <div class="col" aria-label="Column A">
          <div class="colHead">
            <div><strong>Column A</strong> <span class="small">(targets)</span></div>
            <div class="small" id="uiA">—</div>
          </div>
          <div id="targets" class="pairRow"></div>
        </div>

        <!-- Column B: draggable choices -->
        <div class="col" aria-label="Column B">
          <div class="colHead">
            <div><strong>Column B</strong> <span class="small">(choices)</span></div>
            <div class="small" id="uiB">—</div>
          </div>
          <div id="choices" class="tiles"></div>
        </div>
      </div>

      <div class="msg err" id="msgErr"></div>
      <div class="msg warn" id="msgWarn"></div>
      <div class="msg ok" id="msgOk"></div>
    </section>

    <!-- RIGHT: WRITING (TWR + ESOL) -->
    <aside class="card" aria-label="Writing">
      <h2>Writing to Learn (TWR) <span class="req">*</span></h2>
      <div class="small">Writing is part of the game. To finish, you must explain at least one match.</div>

      <div style="height:8px"></div>

      <div class="small"><strong>Sentence Frame (auto-scaffolded by WIDA)</strong></div>
      <textarea id="twrPrompt" readonly></textarea>

      <div style="height:10px"></div>

      <div class="small"><strong>Your Response <span class="req">*</span></strong></div>
      <textarea id="twrResponse" placeholder="Write here…"></textarea>

      <div class="btnrow">
        <button class="ghost" id="btnCopy" type="button">Copy Response</button>
        <button class="ghost" id="btnClear" type="button">Clear</button>
      </div>

      <div class="small"><strong>ESOL Supports</strong></div>
      <textarea id="esolSupports" readonly></textarea>

      <div style="height:10px"></div>

      <div class="rubric">
        <strong>Quick Success Criteria (4-point):</strong><br>
        <strong>4</strong> correct matches + clear explanation using math words + check/compare<br>
        <strong>3</strong> correct matches + explains one match<br>
        <strong>2</strong> some correct + partial explanation<br>
        <strong>1</strong> incomplete
      </div>
    </aside>

  </div>
</div>

<script>
/** =========================
 * MATCHING ENGINE v1.0.0
 * Config loading:
 *  A) ?pairs=<base64url(JSON)>
 *  B) ?configUrl=<https://.../config.json>
 *  C) fallback demo
 * ========================= */

(function(){
  "use strict";

  /** ---------- Utilities ---------- */
  const $ = (id)=>document.getElementById(id);
  const setMsg = (id, show, text)=>{ const el=$(id); el.style.display=show?"block":"none"; el.textContent=text||""; };
  const clearMsgs = ()=>{ setMsg("msgErr",false,""); setMsg("msgWarn",false,""); setMsg("msgOk",false,""); };

  function base64UrlDecodeToString(b64url){
    const s = (b64url||"").replace(/-/g,"+").replace(/_/g,"/");
    const pad = "===".slice((s.length+3)%4);
    try{
      const bytes = atob(s+pad);
      const arr = Uint8Array.from(bytes,c=>c.charCodeAt(0));
      return new TextDecoder("utf-8").decode(arr);
    }catch(_){ return null; }
  }
  const safeJsonParse = (s)=>{ try{ return JSON.parse(s); }catch(_){ return null; }};

  function hashToSeed(str){
    let h=2166136261;
    for(let i=0;i<str.length;i++){ h^=str.charCodeAt(i); h=Math.imul(h,16777619); }
    return h>>>0;
  }
  function mulberry32(seed){
    let a=seed>>>0;
    return function(){
      a|=0; a=a+0x6D2B79F5|0;
      let t=Math.imul(a^a>>>15,1|a);
      t=t+Math.imul(t^t>>>7,61|t)^t;
      return ((t^t>>>14)>>>0)/4294967296;
    };
  }
  function shuffleDeterministic(arr, seedStr){
    const out=arr.slice();
    const rnd=mulberry32(hashToSeed(seedStr));
    for(let i=out.length-1;i>0;i--){
      const j=Math.floor(rnd()*(i+1));
      [out[i],out[j]]=[out[j],out[i]];
    }
    return out;
  }

  function escapeHtml(s){
    return String(s||"")
      .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
      .replaceAll('"',"&quot;").replaceAll("'","&#039;");
  }

  /** ---------- Default Config ---------- */
  const DEFAULT_CFG = {
    version:"1.0.0",
    engine:"matching",
    standard:"6.NS.C.7",
    title:"Opposites on the Number Line",
    prompt:"Match each term to its example.",
    directions:"Click one from Column A, then click the matching choice in Column B. Or drag a choice onto its target.",
    widaLevel:"3-4",
    twr:{ prompt:"I matched ______ with ______ because ______.\nI know because ______.\nI checked by ______." },
    esolSupports:[
      "Word bank: opposite, negative, positive, absolute value, direction.",
      "Sentence starter: I matched ______ to ______ because ______."
    ],
    mastery:{ requireWritingToFinish:true, minWritingChars:40 },
    behavior:{ seed:"", maxHints:3, allowCheckColors:true },
    hint:"Think: opposite numbers are the same distance from 0, but on different sides.",
    misconceptionRules:[
      { key:"opposite-vs-absolute", message:"Opposite is about direction (±). Absolute value is distance from 0 (always non-negative)." }
    ],
    pairs:[
      { id:"p1", a:{text:"Opposite of 7"}, b:{text:"-7"} },
      { id:"p2", a:{text:"Absolute value of -4"}, b:{text:"4"} },
      { id:"p3", a:{text:"Number 3 units left of 0"}, b:{text:"-3"} },
      { id:"p4", a:{text:"Number 6 units right of 0"}, b:{text:"6"} }
    ]
  };

  function validateCfg(cfg){
    const errs=[];
    const mustStr=(k)=>{ if(typeof cfg[k]!=="string"||!cfg[k].trim()) errs.push(`Missing/invalid string: ${k}`); };
    const mustArr=(k)=>{ if(!Array.isArray(cfg[k])||cfg[k].length===0) errs.push(`Missing/invalid array: ${k}`); };

    if(!cfg || typeof cfg!=="object") return {ok:false, errors:["Config is not an object."]};
    mustStr("engine"); if(cfg.engine!=="matching") errs.push("engine must be 'matching'");
    mustStr("standard"); mustStr("title"); mustStr("prompt");
    mustArr("pairs");

    const ids=new Set();
    cfg.pairs.forEach((p,i)=>{
      if(!p||typeof p!=="object") errs.push(`pairs[${i}] invalid`);
      else{
        if(!p.id||typeof p.id!=="string") errs.push(`pairs[${i}].id missing`);
        if(ids.has(p.id)) errs.push(`Duplicate pair id: ${p.id}`);
        ids.add(p.id);
        if(!p.a||typeof p.a.text!=="string") errs.push(`pairs[${i}].a.text missing`);
        if(!p.b||typeof p.b.text!=="string") errs.push(`pairs[${i}].b.text missing`);
      }
    });

    if(cfg.mastery){
      if(typeof cfg.mastery.requireWritingToFinish!=="boolean") errs.push("mastery.requireWritingToFinish must be boolean");
      if(typeof cfg.mastery.minWritingChars!=="number") errs.push("mastery.minWritingChars must be number");
    }
    if(cfg.behavior){
      if(cfg.behavior.maxHints!=null && typeof cfg.behavior.maxHints!=="number") errs.push("behavior.maxHints must be number");
    }
    return {ok:errs.length===0, errors:errs};
  }

  /** ---------- State ---------- */
  let CFG=null;
  let hintCount=0;

  // placements: pairId -> choiceId (bId) or null
  let placements=new Map();

  // choice pool: {id,text}
  let targets=[]; // {pairId,text}
  let choices=[]; // {choiceId,text,pairId} pairId is correct target

  let selectedA=null; // pairId
  let selectedB=null; // choiceId

  let lastCheck=null; // {ok:boolean, wrong:[]}

  /** ---------- Writing ---------- */
  function autoTwrPromptByWida(wida){
    const w=String(wida||"").toLowerCase().trim();
    if(w.includes("1")||w.includes("2")){
      return [
        "I matched ______ with ______.",
        "Because ______.",
        "One math word: ______."
      ].join("\n");
    }
    if(w.includes("3")||w.includes("4")){
      return [
        "I matched ______ with ______ because ______.",
        "I know because ______.",
        "I checked by ______."
      ].join("\n");
    }
    return [
      "Explain one match using math vocabulary and evidence.",
      "Explain how you checked your thinking."
    ].join("\n");
  }

  function renderWriting(){
    const twr = (CFG.twr && CFG.twr.prompt && CFG.twr.prompt.trim())
      ? CFG.twr.prompt.trim()
      : autoTwrPromptByWida(CFG.widaLevel);
    $("twrPrompt").value = twr;

    const supports = Array.isArray(CFG.esolSupports) ? CFG.esolSupports : [];
    $("esolSupports").value = supports.join("\n") || "Add esolSupports in the config for targeted scaffolds.";
  }

  function writingGateOk(){
    const req = CFG.mastery && CFG.mastery.requireWritingToFinish;
    const min = (CFG.mastery && typeof CFG.mastery.minWritingChars==="number") ? CFG.mastery.minWritingChars : 40;
    if(!req) return {ok:true, message:""};
    const txt = ($("twrResponse").value||"").trim();
    if(txt.length < min) return {ok:false, message:`write at least ${min} characters explaining one match.`};
    return {ok:true, message:""};
  }

  /** ---------- Config Loading ---------- */
  async function loadCfg(){
    const url = new URL(window.location.href);
    const pairsB64 = url.searchParams.get("pairs");
    const configUrl = url.searchParams.get("configUrl");

    if(pairsB64){
      const jsonStr = base64UrlDecodeToString(pairsB64);
      const obj = jsonStr ? safeJsonParse(jsonStr) : null;
      if(obj) return obj;
      throw new Error("Invalid pairs parameter (base64url JSON could not be decoded).");
    }
    if(configUrl){
      const res = await fetch(configUrl, { cache:"no-store" });
      if(!res.ok) throw new Error(`configUrl fetch failed (${res.status})`);
      return await res.json();
    }
    return DEFAULT_CFG;
  }

  /** ---------- Build Model ---------- */
  function buildModel(){
    const seedBase = (CFG.behavior && CFG.behavior.seed && CFG.behavior.seed.trim())
      ? CFG.behavior.seed.trim()
      : `${CFG.standard}::${CFG.title}`;

    // targets are pair A texts, keep order stable (but can shuffle too if desired)
    targets = CFG.pairs.map(p=>({ pairId:p.id, text:p.a.text }));

    // choices are pair B texts, shuffled deterministically
    choices = CFG.pairs.map(p=>({ choiceId:`b_${p.id}`, text:p.b.text, pairId:p.id }));
    choices = shuffleDeterministic(choices, seedBase + "::choices");

    placements = new Map();
    targets.forEach(t=>placements.set(t.pairId, null));

    hintCount = 0;
    selectedA = null;
    selectedB = null;
    lastCheck = null;
  }

  /** ---------- UI Render ---------- */
  function renderHeader(){
    $("uiTitle").textContent = CFG.title || "Matching Engine";
    $("uiMeta").textContent = `${CFG.engine} • ${CFG.version||"—"} • ${CFG.standard}`;
    $("uiStandard").textContent = CFG.standard || "—";
    $("uiWida").textContent = CFG.widaLevel || "—";
    $("uiPrompt").textContent = CFG.prompt || "Match items from Column A to Column B.";
    $("uiDirections").textContent = CFG.directions || "Click to match or drag choices onto targets.";
  }

  function renderTargets(){
    const wrap = $("targets");
    wrap.innerHTML = "";

    targets.forEach(t=>{
      const dz = document.createElement("div");
      dz.className = "dropZone";
      dz.id = `target_${t.pairId}`;
      dz.setAttribute("tabindex","0");
      dz.setAttribute("role","button");
      dz.setAttribute("aria-label", `Target: ${t.text}`);

      const placedChoiceId = placements.get(t.pairId);
      const placedChoice = placedChoiceId ? choices.find(c=>c.choiceId===placedChoiceId) : null;

      dz.innerHTML = `
        <div>
          <strong>${escapeHtml(t.text)}</strong>
          <div class="hint">${placedChoice ? "Matched" : "Drop / Click match here"}</div>
        </div>
        <div>
          ${placedChoice ? `<span class="tile good" style="cursor:default;">${escapeHtml(placedChoice.text)}</span>` : `<span class="small">—</span>`}
        </div>
      `;

      // drag over/drop
      dz.addEventListener("dragover", (e)=>{ e.preventDefault(); });
      dz.addEventListener("drop", (e)=>{
        e.preventDefault();
        const choiceId = e.dataTransfer.getData("text/plain");
        if(choiceId) place(t.pairId, choiceId);
      });

      // click selection
      dz.addEventListener("click", ()=>{
        setSelectedA(t.pairId);
        // if B selected, place now
        if(selectedB) place(t.pairId, selectedB);
      });

      dz.addEventListener("keydown",(e)=>{
        if(e.key==="Enter"||e.key===" "){
          e.preventDefault();
          setSelectedA(t.pairId);
          if(selectedB) place(t.pairId, selectedB);
        }
      });

      // highlight if selectedA
      if(selectedA === t.pairId) dz.style.boxShadow = "0 0 0 3px rgba(37,99,235,.25)";
      else dz.style.boxShadow = "none";

      wrap.appendChild(dz);
    });

    $("uiA").textContent = `Targets: ${targets.length}`;
  }

  function renderChoices(){
    const wrap = $("choices");
    wrap.innerHTML = "";

    // show only unplaced choices
    const used = new Set(Array.from(placements.values()).filter(Boolean));
    const remaining = choices.filter(c=>!used.has(c.choiceId));

    remaining.forEach(c=>{
      const tile = document.createElement("div");
      tile.className = "tile";
      tile.id = `choice_${c.choiceId}`;
      tile.setAttribute("tabindex","0");
      tile.setAttribute("role","button");
      tile.setAttribute("aria-label", `Choice: ${c.text}`);
      tile.draggable = true;
      tile.innerHTML = `<div>${escapeHtml(c.text)}</div>`;

      tile.addEventListener("dragstart",(e)=>{
        tile.classList.add("dragging");
        e.dataTransfer.setData("text/plain", c.choiceId);
        e.dataTransfer.effectAllowed = "move";
      });
      tile.addEventListener("dragend",()=>tile.classList.remove("dragging"));

      tile.addEventListener("click", ()=>{
        setSelectedB(c.choiceId);
        if(selectedA) place(selectedA, c.choiceId);
      });
      tile.addEventListener("keydown",(e)=>{
        if(e.key==="Enter"||e.key===" "){
          e.preventDefault();
          setSelectedB(c.choiceId);
          if(selectedA) place(selectedA, c.choiceId);
        }
      });

      if(selectedB === c.choiceId) tile.classList.add("selected");
      wrap.appendChild(tile);
    });

    $("uiB").textContent = `Choices: ${remaining.length}/${choices.length}`;
  }

  function renderAll(){
    clearMsgs();
    renderTargets();
    renderChoices();
    renderWriting();
    // check colors optional on lastCheck (we keep it lightweight; we already show matched choices in targets)
  }

  /** ---------- Selection ---------- */
  function setSelectedA(pairId){
    selectedA = pairId;
    renderTargets(); // update highlights only
  }
  function setSelectedB(choiceId){
    selectedB = choiceId;
    renderChoices(); // update highlights only
  }

  /** ---------- Placement Logic ---------- */
  function place(pairId, choiceId){
    if(!pairId || !choiceId) return;

    // If choice already placed elsewhere, remove it from that target
    for(const [k,v] of placements.entries()){
      if(v === choiceId) placements.set(k, null);
    }

    placements.set(pairId, choiceId);
    lastCheck = null;

    // clear selection after place to reduce confusion
    selectedA = null;
    selectedB = null;

    renderAll();
  }

  function reset(){
    buildModel();
    $("twrResponse").value = "";
    renderAll();
    setMsg("msgWarn", true, "Reset complete. Match again.");
  }

  /** ---------- Hinting ---------- */
  function hint(){
    const maxHints = (CFG.behavior && typeof CFG.behavior.maxHints==="number") ? CFG.behavior.maxHints : 3;
    if(hintCount >= maxHints){
      setMsg("msgWarn", true, `Hint limit reached (${maxHints}). Try checking and revising.`);
      return;
    }
    hintCount++;
    const h = CFG.hint || "Look for key vocabulary and examples that fit the target exactly.";
    setMsg("msgWarn", true, `Hint ${hintCount}/${maxHints}:\n${h}`);
  }

  /** ---------- Checking ---------- */
  function check(){
    clearMsgs();

    const unfilled = Array.from(placements.values()).filter(v=>!v).length;
    if(unfilled > 0){
      setMsg("msgWarn", true, `Keep going: ${unfilled} target(s) still unmatched.`);
      return;
    }

    const wrong = [];
    for(const t of targets){
      const choiceId = placements.get(t.pairId);
      const choice = choices.find(c=>c.choiceId===choiceId);
      if(!choice || choice.pairId !== t.pairId){
        wrong.push({ pairId:t.pairId, choiceId, targetText:t.text, choiceText: choice ? choice.text : "—" });
      }
    }

    if(wrong.length === 0){
      const gate = writingGateOk();
      if(!gate.ok){
        setMsg("msgWarn", true, `Matches are correct ✅\nBefore you finish: ${gate.message}`);
        return;
      }
      setMsg("msgOk", true, "Perfect ✅\nYou matched correctly AND explained your thinking.\nYou may move to the next activity.");
      return;
    }

    // misconception hook (light v1)
    let extra = "";
    if(Array.isArray(CFG.misconceptionRules) && CFG.misconceptionRules.length){
      extra = "\n\nCommon issue to check:\n• " + (CFG.misconceptionRules[0].message || "");
    }

    setMsg("msgErr", true, `Not yet.\nWrong matches: ${wrong.length}/${targets.length}${extra}`);
  }

  /** ---------- Buttons ---------- */
  $("btnReset").addEventListener("click", reset);
  $("btnHint").addEventListener("click", hint);
  $("btnCheck").addEventListener("click", check);

  $("btnCopy").addEventListener("click", async ()=>{
    try{
      await navigator.clipboard.writeText($("twrResponse").value || "");
      setMsg("msgWarn", true, "Copied response to clipboard.");
    }catch(_){
      setMsg("msgWarn", true, "Copy failed (browser permission). Select text and copy manually.");
    }
  });
  $("btnClear").addEventListener("click", ()=>{ $("twrResponse").value=""; });

  /** ---------- Boot ---------- */
  async function boot(){
    try{
      const cfg = await loadCfg();
      const merged = { ...DEFAULT_CFG, ...cfg };

      // merge nested objects shallowly
      merged.twr = { ...(DEFAULT_CFG.twr||{}), ...(cfg.twr||{}) };
      merged.mastery = { ...(DEFAULT_CFG.mastery||{}), ...(cfg.mastery||{}) };
      merged.behavior = { ...(DEFAULT_CFG.behavior||{}), ...(cfg.behavior||{}) };

      const v = validateCfg(merged);
      if(!v.ok) throw new Error("Config validation failed:\n• " + v.errors.join("\n• "));

      CFG = merged;

      renderHeader();
      buildModel();
      renderAll();

      setMsg("msgWarn", true, "Tip: Click-to-match OR drag choices onto targets.\nFinish by writing an explanation for at least one match.");

    }catch(err){
      $("uiMeta").textContent = "Config error";
      setMsg("msgErr", true, String(err && err.message ? err.message : err));
    }
  }

  boot();
})();
</script>
</body>
</html>